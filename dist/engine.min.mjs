import nullOperator from"./operators/nullOperator.mjs";import undefinedOperator from"./operators/undefinedOperator.mjs";import NaNOperator from"./operators/NaNOperator.mjs";import InfinityOperator from"./operators/InfinityOperator.mjs";import ArrayOperator from"./operators/ArrayOperator.mjs";import ObjectOperator from"./operators/ObjectOperator.mjs";import trueOperator from"./operators/trueOperator.mjs";import falseOperator from"./operators/falseOperator.mjs";class Engine{constructor(e){const a=this;this.namespace=new Map;const r={arg:2,body:(e,r)=>(a.namespace.set(r,e),null)},t={arg:1,body:e=>a.namespace.get(e)},s={arg:1,body:e=>(a.namespace.delete(e),null)},o={arg:2,body:(e,r)=>(a.namespace.set(r,a.namespace.get(r)+e),null)},l={arg:2,body:(e,r)=>(a.namespace.set(r,a.namespace.get(r)-e),null)},n={arg:2,body:(e,r)=>(a.namespace.set(r,a.namespace.get(r)*e),null)},p={arg:2,body:(e,r)=>(a.namespace.set(r,a.namespace.get(r)/e),null)},i={arg:2,body:(e,r)=>(a.namespace.set(r,a.namespace.get(r)%e),null)},c={arg:2,body:(e,r)=>(a.namespace.set(r,a.namespace.get(r)**e),null)},m={arg:1,body:e=>(this.eval(e),null)},u={arg:3,body:(e,a,r)=>(r?this.eval(a):this.eval(e),null)},h={arg:3,body:(e,a,r)=>(r?this.eval(e):this.eval(a),null)},f={arg:3,body:(e,r,t)=>{for(let s=0;s<r.length;s++)a.namespace.set(t,r[s]),this.eval(e);return a.namespace.delete(t),null}},g={arg:2,body:(e,a)=>{for(;;){if(this.eval(a),!this.stack[this.stack.length-1]){this.stack.pop();break}this.eval(e)}return null}},d={arg:2,body:(e,a)=>{for(;;){if(this.eval(a),this.stack[this.stack.length-1]){this.stack.pop();break}this.eval(e)}return null}},y={arg:2,body:(e,a)=>(Array(a).fill(0).forEach(()=>{this.eval(e)}),null)},O={arg:2,body:(e,r)=>(a.namespace.set(r,[...a.namespace.get(r),e]),null)};this.operators={$true:trueOperator,$false:falseOperator,$null:nullOperator,$undefined:undefinedOperator,$NaN:NaNOperator,$Infinity:InfinityOperator,"[]":ArrayOperator,"{}":ObjectOperator,"=":r,"+=":o,"-=":l,"*=":n,"/=":p,"%=":i,"**=":c,$:t,"!delete":s,"!eval":m,"!if":u,"!unless":h,"!each":f,"!while":g,"!until":d,"!times":y,"!push":O,...e},this.stack=[],this.namespace.set("stack",this.stack)}eval(e){e.forEach(e=>{if("$null"===e)this.stack.push(null);else if(this.operators[e]){const a=[];Array(this.operators[e].arg).fill(0).forEach(e=>{a.push(this.stack.pop())});const r=this.operators[e].body(...a);if(null===r)return;this.stack.push(r)}else this.stack.push(e);return this.stack})}}export default Engine;